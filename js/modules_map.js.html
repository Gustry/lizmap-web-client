<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: modules/map.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: modules/map.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module modules/maps.js
 * @name maps
 * @copyright 2023 3Liz
 * @license MPL-2.0
 */

import { mainLizmap, mainEventDispatcher } from './Globals.js';
import Utils from './Utils.js';
import { BaseLayerTypes } from './config/BaseLayer.js';
import { MapLayerLoadStatus } from './state/MapLayer.js';
import olMap from 'ol/Map.js';
import View from 'ol/View.js';
import { ADJUSTED_DPI } from '../utils/Constants.js';
import { get as getProjection, getPointResolution } from 'ol/proj.js';
import { Attribution } from 'ol/control.js';
import ImageWMS from 'ol/source/ImageWMS.js';
import WMTS, {optionsFromCapabilities} from 'ol/source/WMTS.js';
import { WMTSCapabilities, GeoJSON, WKT } from 'ol/format.js';
import WMTSTileGrid from 'ol/tilegrid/WMTS.js';
import {getWidth} from 'ol/extent.js';
import {Image as ImageLayer, Tile as TileLayer} from 'ol/layer.js';
import TileGrid from 'ol/tilegrid/TileGrid.js';
import TileWMS from 'ol/source/TileWMS.js';
import XYZ from 'ol/source/XYZ.js';
import BingMaps from 'ol/source/BingMaps.js';
import LayerGroup from 'ol/layer/Group.js';
import { Vector as VectorSource } from 'ol/source.js';
import { Vector as VectorLayer } from 'ol/layer.js';

import DragPan from "ol/interaction/DragPan.js";
import MouseWheelZoom from "ol/interaction/MouseWheelZoom.js";
import DoubleClickZoom from 'ol/interaction/DoubleClickZoom.js';
import DragZoom from 'ol/interaction/DragZoom.js';
import { defaults as defaultInteractions } from 'ol/interaction.js';
import { always } from 'ol/events/condition.js';

/**
 * Class initializing Openlayers Map.
 * @class
 * @name map
 * @augments olMap
 */
export default class map extends olMap {

    constructor() {
        const qgisProjectProjection = mainLizmap.projection;
        const mapProjection = getProjection(qgisProjectProjection);

        // Get resolutions from OL2 map
        let resolutions = mainLizmap.lizmap3.map.resolutions ? mainLizmap.lizmap3.map.resolutions : mainLizmap.lizmap3.map.baseLayer.resolutions;
        if (resolutions == undefined) {
            resolutions= [mainLizmap.lizmap3.map.resolution];
        }
        // Remove duplicated values
        resolutions = [... new Set(resolutions)];
        // Sorting in descending order
        resolutions = resolutions.sort((a, b) => a &lt; b);

        super({
            controls: [
                new Attribution({ target: 'attribution-ol', collapsed: false })
            ],
            interactions: defaultInteractions({
                dragPan: false,
                mouseWheelZoom: false
            }).extend([
                new DragPan(),
                new MouseWheelZoom({ duration: 0 }),
                new DoubleClickZoom({ duration: 0 })
            ]),
            view: new View({
                resolutions: resolutions,
                constrainResolution: true,
                center: [mainLizmap.lizmap3.map.getCenter().lon, mainLizmap.lizmap3.map.getCenter().lat],
                projection: mapProjection,
                enableRotation: false,
                extent: mainLizmap.lizmap3.map.restrictedExtent.toArray(),
                constrainOnlyCenter: true // allow view outside the restricted extent when zooming
            }),
            target: 'newOlMap'
        });

        this._newOlMap = true;

        // Zoom to box
        const dragZoom = new DragZoom({
            condition: always
        });

        document.querySelector('#navbar .pan').addEventListener('click', () => {
            this.removeInteraction(dragZoom);
        });

        document.querySelector('#navbar .zoom').addEventListener('click', () => {
            this.addInteraction(dragZoom);
        });

        this._dispatchMapStateChanged = () => {
            const view = this.getView();
            const projection = view.getProjection();
            const dpi = ADJUSTED_DPI;
            const inchesPerMeter = 1000 / 25.4;
            const resolution = view.getResolution();
            const scaleDenominator = resolution * inchesPerMeter * dpi;
            // The Scale line control uses this method to defined scale denominator
            const pointResolution = getPointResolution(projection, view.getResolution(), view.getCenter(), projection.getUnits());
            const pointScaleDenominator = pointResolution * inchesPerMeter * dpi;

            mainLizmap.state.map.update({
                'type': 'map.state.changing',
                'projection': projection.getCode(),
                'center': [...view.getCenter()],
                'size': [...this.getSize()],
                'extent': view.calculateExtent(),
                'resolution': resolution,
                'scaleDenominator': scaleDenominator,
                'pointResolution': pointResolution,
                'pointScaleDenominator': pointScaleDenominator,
            });
        };

        // Ratio between WMS single tiles and map viewport
        this._WMSRatio = 1.1;

        // Respecting WMS max size
        const wmsMaxSize = [
            mainLizmap.initialConfig.options.wmsMaxWidth,
            mainLizmap.initialConfig.options.wmsMaxHeight,
        ];

        // Get pixel ratio
        const pixelRatio = this.pixelRatio_;

        const useTileWms = this.getSize().reduce(
            (r /*accumulator*/, x /*currentValue*/, i /*currentIndex*/) => r || Math.ceil(x*this._WMSRatio*pixelRatio) > wmsMaxSize[i],
            false,
        );

        const customTileGrid = useTileWms ? new TileGrid({
            extent: mainLizmap.lizmap3.map.restrictedExtent.toArray(),
            resolutions: resolutions,
            tileSize: this.getSize().map((x, i) => {
                // Get the min value between the map size and the max size
                // divided by pixel ratio
                const vMin = Math.min(
                    Math.floor(x/pixelRatio),
                    Math.floor(wmsMaxSize[i]/pixelRatio)
                );
                // If the min value with a margin of WMS ratio is less
                // than max size divided by pixel ratio the keep it
                if (vMin*this._WMSRatio &lt; wmsMaxSize[i]/pixelRatio) {
                    return vMin;
                }
                // Else get the min value divided by WMS ratio
                return Math.floor(vMin/this._WMSRatio);
            })
        }) : null;

        // Mapping between states and OL layers and groups
        this._statesOlLayersandGroupsMap = new Map();

        // Array of layers and groups in overlayLayerGroup
        this._overlayLayersAndGroups = [];

        const layersCount = mainLizmap.state.rootMapGroup.countExplodedMapLayers();

        // Returns a layer or a layerGroup depending of the node type
        const createNode = (node, statesOlLayersandGroupsMap, overlayLayersAndGroups, metersPerUnit, WMSRatio) => {
            if(node.type === 'group'){
                const layers = [];
                for (const layer of node.children.slice().reverse()) {
                    // Keep only layers with a geometry and groups
                    if(node.type !== 'layer' &amp;&amp; node.type !== 'group'){
                        continue;
                    }
                    layers.push(createNode(layer, statesOlLayersandGroupsMap, overlayLayersAndGroups, metersPerUnit, WMSRatio));
                }
                const layerGroup = new LayerGroup({
                    layers: layers
                });

                if (node.name !== 'root') {
                    layerGroup.setVisible(node.visibility);
                    layerGroup.setProperties({
                        name: node.name
                    });

                    statesOlLayersandGroupsMap.set(node.name, [node, layerGroup]);
                    overlayLayersAndGroups.push(layerGroup);
                }

                return layerGroup;
            } else {
                let layer;
                // Keep only layers with a geometry
                if(node.type !== 'layer'){
                    return;
                }

                /* Sometimes throw an Error and extent is not used
                let extent = node.layerConfig.extent;
                if(node.layerConfig.crs !== "" &amp;&amp; node.layerConfig.crs !== mainLizmap.projection){
                    extent = transformExtent(extent, node.layerConfig.crs, mainLizmap.projection);
                }
                */

                // Set min/max resolution only if different from default
                let minResolution = node.wmsMinScaleDenominator &lt;= 1 ? undefined : Utils.getResolutionFromScale(node.layerConfig.minScale, metersPerUnit);
                let maxResolution = node.wmsMaxScaleDenominator &lt;= 1 ? undefined : Utils.getResolutionFromScale(node.layerConfig.maxScale, metersPerUnit);

                // The layer is configured to be cached
                if (node.layerConfig.cached) {
                    // Using WMTS
                    const parser = new WMTSCapabilities();
                    const result = parser.read(lizMap.wmtsCapabilities);

                    // Build WMTS options
                    let options;
                    if (result['Contents']['Layer']) {
                        options = optionsFromCapabilities(result, {
                            layer: node.wmsName,
                            matrixSet: mainLizmap.projection,
                        });
                    }

                    // The options could be null if the layer has not be found in
                    // WMTS capabilities
                    if (options) {
                        layer = new TileLayer({
                            minResolution: minResolution,
                            maxResolution: maxResolution,
                            source: new WMTS(options)
                        });
                    }
                }

                // The layer has not been yet build
                if (!layer) {
                    layer = new ImageLayer({
                        // extent: extent,
                        minResolution: minResolution,
                        maxResolution: maxResolution,
                        source: new ImageWMS({
                            url: mainLizmap.serviceURL,
                            serverType: 'qgis',
                            ratio: WMSRatio,
                            params: {
                                LAYERS: node.wmsName,
                                FORMAT: node.layerConfig.imageFormat,
                                STYLES: node.wmsSelectedStyleName,
                                DPI: 96
                            },
                        })
                    });

                    // Force no cache w/ Firefox
                    if(navigator.userAgent.includes("Firefox")){
                        layer.getSource().setImageLoadFunction((image, src) => {
                            (image.getImage()).src = src + '&amp;ts=' + Date.now();
                        });
                    }

                    if (useTileWms) {
                        layer = new TileLayer({
                            // extent: extent,
                            minResolution: minResolution,
                            maxResolution: maxResolution,
                            source: new TileWMS({
                                url: mainLizmap.serviceURL,
                                serverType: 'qgis',
                                tileGrid: customTileGrid,
                                params: {
                                    LAYERS: node.wmsName,
                                    FORMAT: node.layerConfig.imageFormat,
                                    STYLES: node.wmsSelectedStyleName,
                                    DPI: 96,
                                    TILED: 'true'
                                },
                                wrapX: false, // do not reused across the 180° meridian.
                                //hidpi: false, pixelRatio is used in useTileWms and customTileGrid definition
                            })
                        });

                        // Force no cache w/ Firefox
                        if(navigator.userAgent.includes("Firefox")){
                            layer.getSource().setTileLoadFunction((image, src) => {
                                (image.getImage()).src = src + '&amp;ts=' + Date.now();
                            });
                        }
                    }

                }

                layer.setVisible(node.visibility);

                layer.setOpacity(node.opacity);

                layer.setProperties({
                    name: node.name
                });

                layer.getSource().setProperties({
                    name: node.name
                });

                // OL layers zIndex is the reverse of layer's order given by cfg
                layer.setZIndex(layersCount - 1 - node.layerOrder);

                overlayLayersAndGroups.push(layer);
                statesOlLayersandGroupsMap.set(node.name, [node, layer]);
                return layer;
            }
        }

        this._overlayLayersGroup = new LayerGroup();

        const metersPerUnit = this.getView().getProjection().getMetersPerUnit();
        if(mainLizmap.state.layerTree.children.length){
            this._overlayLayersGroup = createNode(
                mainLizmap.state.rootMapGroup,
                this._statesOlLayersandGroupsMap,
                this._overlayLayersAndGroups,
                metersPerUnit,
                this._WMSRatio
            );
        }

        // Get the base layers zIndex which is the layer min zIndex - 1
        // to be sure base layers are under the others layers
        const baseLayerZIndex = this.overlayLayers.map((layer) => layer.getZIndex()).reduce(
            (minValue, currentValue) => minValue &lt;= currentValue ? minValue : currentValue,
            0
        ) - 1;

        this._hasEmptyBaseLayer = false;
        const baseLayers = [];

        for (const baseLayerState of mainLizmap.state.baseLayers.getBaseLayers()) {
            let baseLayer;
            if (baseLayerState.type === BaseLayerTypes.XYZ) {
                baseLayer = new TileLayer({
                    source: new XYZ({
                        url: baseLayerState.url,
                        projection: baseLayerState.crs,
                        minZoom: baseLayerState.zmin,
                        maxZoom: baseLayerState.zmax,
                    })
                });
            } else if (baseLayerState.type === BaseLayerTypes.WMS) {
                let minResolution = baseLayerState.wmsMinScaleDenominator &lt;= 1 ? undefined : Utils.getResolutionFromScale(baseLayerState.layerConfig.minScale, metersPerUnit);
                let maxResolution = baseLayerState.wmsMaxScaleDenominator &lt;= 1 ? undefined : Utils.getResolutionFromScale(baseLayerState.layerConfig.maxScale, metersPerUnit);
                baseLayer = new ImageLayer({
                    minResolution: minResolution,
                    maxResolution: maxResolution,
                    source: new ImageWMS({
                        url: baseLayerState.url,
                        projection: baseLayerState.crs,
                        ratio: this._WMSRatio,
                        params: {
                            LAYERS: baseLayerState.layers,
                            STYLES: baseLayerState.styles,
                            FORMAT: baseLayerState.format
                        },
                    })
                });
            } else if (baseLayerState.type === BaseLayerTypes.WMTS) {
                const proj3857 = getProjection('EPSG:3857');
                const maxResolution = getWidth(proj3857.getExtent()) / 256;
                const resolutions = [];
                const matrixIds = [];

                for (let i = 0; i &lt; baseLayerState.numZoomLevels; i++) {
                    matrixIds[i] = i.toString();
                    resolutions[i] = maxResolution / Math.pow(2, i);
                }

                const tileGrid = new WMTSTileGrid({
                    origin: [-20037508, 20037508],
                    resolutions: resolutions,
                    matrixIds: matrixIds,
                });

                let url = baseLayerState.url;
                if(baseLayerState.key &amp;&amp; url.includes('{key}')){
                    url = url.replaceAll('{key}', baseLayerState.key);
                }

                baseLayer = new TileLayer({
                    source: new WMTS({
                        url: url,
                        layer: baseLayerState.layer,
                        matrixSet: baseLayerState.matrixSet,
                        format: baseLayerState.format,
                        projection: baseLayerState.crs,
                        tileGrid: tileGrid,
                        style: baseLayerState.style
                    })
                });
            } else if (baseLayerState.type === BaseLayerTypes.Bing) {
                baseLayer = new TileLayer({
                    preload: Infinity,
                    source: new BingMaps({
                        key: baseLayerState.key,
                        imagerySet: baseLayerState.imagerySet,
                    // use maxZoom 19 to see stretched tiles instead of the BingMaps
                    // "no photos at this zoom level" tiles
                    // maxZoom: 19
                    }),
                });
            } else if (baseLayerState.type === BaseLayerTypes.Lizmap) {
                let minResolution = baseLayerState.wmsMinScaleDenominator &lt;= 1 ? undefined : Utils.getResolutionFromScale(baseLayerState.layerConfig.minScale, metersPerUnit);
                let maxResolution = baseLayerState.wmsMaxScaleDenominator &lt;= 1 ? undefined : Utils.getResolutionFromScale(baseLayerState.layerConfig.maxScale, metersPerUnit);

                if (baseLayerState.layerConfig.cached) {
                    const parser = new WMTSCapabilities();
                    const result = parser.read(lizMap.wmtsCapabilities);
                    const options = optionsFromCapabilities(result, {
                        layer: baseLayerState.itemState.wmsName,
                        matrixSet: mainLizmap.projection,
                    });

                    baseLayer = new TileLayer({
                        minResolution: minResolution,
                        maxResolution: maxResolution,
                        source: new WMTS(options)
                    });
                } else {
                    baseLayer = new ImageLayer({
                        // extent: extent,
                        minResolution: minResolution,
                        maxResolution: maxResolution,
                        source: new ImageWMS({
                            url: mainLizmap.serviceURL,
                            projection: qgisProjectProjection,
                            serverType: 'qgis',
                            ratio: this._WMSRatio,
                            params: {
                                LAYERS: baseLayerState.itemState.wmsName,
                                FORMAT: baseLayerState.layerConfig.imageFormat,
                                DPI: 96
                            },
                        })
                    });
                    if (useTileWms) {
                        baseLayer = new TileLayer({
                            // extent: extent,
                            minResolution: minResolution,
                            maxResolution: maxResolution,
                            source: new TileWMS({
                                url: mainLizmap.serviceURL,
                                projection: qgisProjectProjection,
                                serverType: 'qgis',
                                tileGrid: customTileGrid,
                                params: {
                                    LAYERS: baseLayerState.itemState.wmsName,
                                    FORMAT: baseLayerState.layerConfig.imageFormat,
                                    DPI: 96,
                                    TILED: 'true'
                                },
                                wrapX: false, // do not reused across the 180° meridian.
                                //hidpi: false, pixelRatio is used in useTileWms and customTileGrid definition
                            })
                        });
                    }
                }
            } else if (baseLayerState.type === BaseLayerTypes.Empty) {
                this._hasEmptyBaseLayer = true;
            }

            if (!baseLayer) {
                continue;
            }

            if (baseLayerState.hasAttribution) {
                const url = baseLayerState.attribution.url;
                const title = baseLayerState.attribution.title;
                let attribution = title;

                if (url) {
                    attribution = `&lt;a href='${url}' target='_blank'>${title}&lt;/a>`;
                }

                baseLayer.getSource().setAttributions(attribution);
            }

            const visible = mainLizmap.initialConfig.baseLayers.startupBaselayerName === baseLayerState.name;

            baseLayer.setProperties({
                name: baseLayerState.name,
                title: baseLayerState.title,
                visible: visible
            });

            // Force baselayer to be under the others layers
            baseLayer.setZIndex(baseLayerZIndex);

            baseLayers.push(baseLayer);

            if (visible &amp;&amp; baseLayer.getSource().getProjection().getCode() !== qgisProjectProjection) {
                this.getView().getProjection().setExtent(mainLizmap.lizmap3.map.restrictedExtent.toArray());
            }
        }

        this._baseLayersGroup;

        if (baseLayers.length) {
            this._baseLayersGroup = new LayerGroup({
                layers: baseLayers
            });
        } else {
            this._baseLayersGroup = new LayerGroup();
        }

        // Add base and overlay layers to the map's main LayerGroup
        this.setLayerGroup(new LayerGroup({
            layers: [this._baseLayersGroup, this._overlayLayersGroup]
        }));

        // Sync new OL view with OL2 view
        mainLizmap.lizmap3.map.events.on({
            move: () => {
                this.syncNewOLwithOL2View();
            }
        });

        // Sync OL2 view with new OL view
        this.on('pointerdrag', () => {
            mainLizmap.lizmap3.map.setCenter(
                this.getView().getCenter(),
                null,
                true // avoid many WMS request in OL2 map and also movestart/end events.
            );
        });

        this.on('moveend', this.refreshOL2View);

        // Init view
        this.syncNewOLwithOL2View();

        // Listen/Dispatch events
        this.getView().on('change:resolution', () => {
            mainEventDispatcher.dispatch('resolution.changed');
        });

        this._baseLayersGroup.on('change', () => {
            mainEventDispatcher.dispatch('baseLayers.changed');
        });

        this._overlayLayersGroup.on('change', () => {
            mainEventDispatcher.dispatch('overlayLayers.changed');
        });

        for (const layer of this.overlayLayers) {
            const source = layer.getSource();

            if (source instanceof ImageWMS) {
                source.on('imageloadstart', event => {
                    const mapLayer = mainLizmap.state.rootMapGroup.getMapLayerByName(event.target.get('name'))
                    mapLayer.loadStatus = MapLayerLoadStatus.Loading;
                });
                source.on('imageloadend', event => {
                    const mapLayer = mainLizmap.state.rootMapGroup.getMapLayerByName(event.target.get('name'))
                    mapLayer.loadStatus = MapLayerLoadStatus.Ready;
                });
                source.on('imageloaderror', event => {
                    const mapLayer = mainLizmap.state.rootMapGroup.getMapLayerByName(event.target.get('name'))
                    mapLayer.loadStatus = MapLayerLoadStatus.Error;
                });
            } else if (source instanceof WMTS) {
                source.on('tileloadstart', event => {
                    const mapLayer = mainLizmap.state.rootMapGroup.getMapLayerByName(event.target.get('name'))
                    mapLayer.loadStatus = MapLayerLoadStatus.Loading;
                });
                source.on('tileloadend', event => {
                    const mapLayer = mainLizmap.state.rootMapGroup.getMapLayerByName(event.target.get('name'))
                    mapLayer.loadStatus = MapLayerLoadStatus.Ready;
                });
                source.on('tileloaderror', event => {
                    const mapLayer = mainLizmap.state.rootMapGroup.getMapLayerByName(event.target.get('name'))
                    mapLayer.loadStatus = MapLayerLoadStatus.Error;
                });
            }
        }

        mainLizmap.state.rootMapGroup.addListener(
            evt => this.getLayerOrGroupByName(evt.name).setVisible(evt.visibility),
            ['layer.visibility.changed', 'group.visibility.changed']
        );

        mainLizmap.state.layersAndGroupsCollection.addListener(
            evt => {
                const activeBaseLayer = this.getActiveBaseLayer();
                if (activeBaseLayer &amp;&amp; activeBaseLayer.get("name") === evt.name) {
                    activeBaseLayer.setOpacity(evt.opacity);
                } else {
                    this.getLayerOrGroupByName(evt.name).setOpacity(evt.opacity);
                }
            },
            ['layer.opacity.changed', 'group.opacity.changed']
        );

        mainLizmap.state.rootMapGroup.addListener(
            evt => {
                const [state, olLayer] = this._statesOlLayersandGroupsMap.get(evt.name);
                const wmsParams = olLayer.getSource().getParams();

                // Delete entries in `wmsParams` not in `state.wmsParameters`
                for(const key of Object.keys(wmsParams)){
                    if(!Object.hasOwn(state.wmsParameters, key)){
                        delete wmsParams[key];
                    }
                }
                Object.assign(wmsParams, state.wmsParameters);

                olLayer.getSource().updateParams(wmsParams);
            },
            ['layer.symbol.checked.changed', 'layer.style.changed', 'layer.selection.token.changed', 'layer.filter.token.changed']
        );

        mainLizmap.state.baseLayers.addListener(
            evt => {
                this.changeBaseLayer(evt.name);
            },
            ['baselayers.selection.changed']
        );

        // Create the highlight layer
        // used to display features on top of all layers
        const styleColor = 'rgba(255,255,0,0.8)';
        const styleWidth = 3;
        this._highlightLayer = new VectorLayer({
            source: new VectorSource({
                wrapX: false
            }),
            style: {
                'circle-stroke-color': styleColor,
                'circle-stroke-width': styleWidth,
                'circle-radius': 6,
                'stroke-color': styleColor,
                'stroke-width': styleWidth,
            }
        });
        this.addLayer(this._highlightLayer);

        // Add startup features to map if any
        const startupFeatures = mainLizmap.state.map.startupFeatures;
        if (startupFeatures) {
            this.setHighlightFeatures(startupFeatures, "geojson");
        }
    }

    get hasEmptyBaseLayer() {
        return this._hasEmptyBaseLayer;
    }

    get baseLayersGroup(){
        return this._baseLayersGroup;
    }

    get overlayLayersAndGroups(){
        return this._overlayLayersAndGroups;
    }

    // Get overlay layers (not layerGroups)
    get overlayLayers(){
        return this._overlayLayersGroup.getLayersArray();
    }

    get overlayLayersGroup(){
        return this._overlayLayersGroup;
    }

    /**
     * Add highlight features on top of all layer
     * @param {string} features features as GeoJSON or WKT
     * @param {string} format format string as `geojson` or `wkt`
     * @param {string|undefined} projection optional features projection
     */
    addHighlightFeatures(features, format, projection) {
        let olFeatures;
        if (format === "geojson") {
            olFeatures = (new GeoJSON()).readFeatures(features, {
                dataProjection: projection,
                featureProjection: mainLizmap.projection
            });
        } else if (format === "wkt") {
            olFeatures = (new WKT()).readFeatures(features, {
                dataProjection: projection,
                featureProjection: mainLizmap.projection
            });
        } else {
            return;
        }
        this._highlightLayer.getSource().addFeatures(olFeatures);
    }

    /**
     * Set highlight features on top of all layer
     * @param {string} features features as GeoJSON or WKT
     * @param {string} format format string as `geojson` or `wkt`
     * @param {string|undefined} projection optional features projection
     */
    setHighlightFeatures(features, format, projection){
        this.clearHighlightFeatures();
        this.addHighlightFeatures(features, format, projection);
    }

    /**
     * Clear all highlight features
     */
    clearHighlightFeatures() {
        this._highlightLayer.getSource().clear();
    }

    /**
     * Synchronize new OL view with OL2 one
     * @memberof Map
     */
    syncNewOLwithOL2View(){
        this.getView().animate({
            center: mainLizmap.center,
            zoom: mainLizmap.lizmap3.map.getZoom(),
            duration: 50
        });
    }

    refreshOL2View() {
        // This refresh OL2 view and layers
        mainLizmap.lizmap3.map.setCenter(
            this.getView().getCenter(),
            this.getView().getZoom()
        );
    }

    changeBaseLayer(name){
        let selectedBaseLayer;
        // Choosen base layer is visible, others not
        this.baseLayersGroup.getLayers().forEach( baseLayer => {
            if (baseLayer.get('name') === name) {
                selectedBaseLayer = baseLayer;
                baseLayer.set("visible", true, true);
            } else {
                baseLayer.set("visible", false, true);
            }
        });

        this._baseLayersGroup.changed();

        // If base layer projection is different from project projection
        // We must set the project extent to the View to reproject nicely
        if (selectedBaseLayer?.getSource().getProjection().getCode() !== mainLizmap.projection) {
            this.getView().getProjection().setExtent(mainLizmap.lizmap3.map.restrictedExtent.toArray());
        } else {
            this.getView().getProjection().setExtent(getProjection(mainLizmap.projection).getExtent());
        }

        // Trigger legacy event
        lizMap.events.triggerEvent("lizmapbaselayerchanged", { 'layer': name });

        // Refresh metadatas if sub-dock is visible
        if ( document.getElementById('sub-dock').offsetParent !== null ) {
            lizMap.events.triggerEvent("lizmapswitcheritemselected", {
                'name': name, 'type': 'baselayer', 'selected': true
            });
        }
    }

    getActiveBaseLayer(){
        return this._baseLayersGroup.getLayers().getArray().find(
            layer => layer.getVisible()
        );
    }

    /**
     * Return overlay layer if `name` matches.
     * `name` is unique for every layers
     * @param name
     * @returns {Layer|undefined}
     */
    getLayerByName(name){
        return this.overlayLayers.find(
            layer => layer.get('name') === name
        );
    }

    /**
     * Return overlay layer or group if `name` matches.
     * `name` is unique for every layers/groups
     * @param name
     * @returns {Layer|LayerGroup|undefined}
     */
    getLayerOrGroupByName(name){
        return this.overlayLayersAndGroups.find(
            layer => layer.get('name') === name
        );
    }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Action.html">Action</a></li><li><a href="module-ActionSelector.html">ActionSelector</a></li><li><a href="module-Atlas.html">Atlas</a></li><li><a href="module-AttributeTable.html">AttributeTable</a></li><li><a href="module-Attribution.html">Attribution</a></li><li><a href="module-BaseLayer.html">BaseLayer</a></li><li><a href="module-BaseLayerState.html">BaseLayerState</a></li><li><a href="module-BaseLayers.html">BaseLayers</a></li><li><a href="module-BaseObject.html">BaseObject</a></li><li><a href="module-BottomDock.html">BottomDock</a></li><li><a href="module-Config.html">Config</a></li><li><a href="module-Constants.html">Constants</a></li><li><a href="module-Converters.html">Converters</a></li><li><a href="module-Dataviz.html">Dataviz</a></li><li><a href="module-Digitizing.html">Digitizing</a></li><li><a href="module-Draw.html">Draw</a></li><li><a href="module-Edition.html">Edition</a></li><li><a href="module-Enums.html">Enums</a></li><li><a href="module-Errors.html">Errors</a></li><li><a href="module-Extent.html">Extent</a></li><li><a href="module-FeatureStorage.html">FeatureStorage</a></li><li><a href="module-FeatureToolbar.html">FeatureToolbar</a></li><li><a href="module-Filter.html">Filter</a></li><li><a href="module-FormFilter.html">FormFilter</a></li><li><a href="module-FullScreen.html">FullScreen</a></li><li><a href="module-Geolocation.html">Geolocation</a></li><li><a href="module-GeolocationSurvey.html">GeolocationSurvey</a></li><li><a href="module-Index.html">Index</a></li><li><a href="module-Layer.html">Layer</a></li><li><a href="module-LayerState.html">LayerState</a></li><li><a href="module-LayerTree.html">LayerTree</a></li><li><a href="module-LayerTreeState.html">LayerTreeState</a></li><li><a href="module-LayersOrder.html">LayersOrder</a></li><li><a href="module-Legend.html">Legend</a></li><li><a href="module-Locate.html">Locate</a></li><li><a href="module-MGRS.html">MGRS</a></li><li><a href="module-MapLayerState.html">MapLayerState</a></li><li><a href="module-MapState.html">MapState</a></li><li><a href="module-Mask.html">Mask</a></li><li><a href="module-Metadata.html">Metadata</a></li><li><a href="module-MousePosition.html">MousePosition</a></li><li><a href="module-Options.html">Options</a></li><li><a href="module-OverviewMap.html">OverviewMap</a></li><li><a href="module-PasteGeom.html">PasteGeom</a></li><li><a href="module-Permalink.html">Permalink</a></li><li><a href="module-Popup.html">Popup</a></li><li><a href="module-Print.html">Print</a></li><li><a href="module-PrintTemplate.html">PrintTemplate</a></li><li><a href="module-ProxyEvents.html">ProxyEvents</a></li><li><a href="module-ReverseGeom.html">ReverseGeom</a></li><li><a href="module-Scaleline.html">Scaleline</a></li><li><a href="module-Search.html">Search</a></li><li><a href="module-SelectionInvert.html">SelectionInvert</a></li><li><a href="module-SelectionTool.html">SelectionTool</a></li><li><a href="module-Snapping.html">Snapping</a></li><li><a href="module-State.html">State</a></li><li><a href="module-Switch%2520layer%2520actions.html">Switch layer actions</a></li><li><a href="module-SymbologyAction.html">SymbologyAction</a></li><li><a href="module-SymbologyState.html">SymbologyState</a></li><li><a href="module-Theme.html">Theme</a></li><li><a href="module-Time%2520manager.html">Time manager</a></li><li><a href="module-TimeManager.html">TimeManager</a></li><li><a href="module-Tools.html">Tools</a></li><li><a href="module-Tooltip.html">Tooltip</a></li><li><a href="module-Treeview.html">Treeview</a></li><li><a href="module-Utils.html">Utils</a></li><li><a href="module-View.html">View</a></li><li><a href="module-WFS.html">WFS</a></li><li><a href="module-WMS.html">WMS</a></li><li><a href="module-maps.html">maps</a></li></ul><h3>Classes</h3><ul><li><a href="EventDispatcher.html">EventDispatcher</a></li><li><a href="module-Action.html">Action</a></li><li><a href="module-ActionSelector-ActionSelector.html">ActionSelector</a></li><li><a href="module-Action-Action.html">Action</a></li><li><a href="module-AttributeTable.AttributeLayerConfig.html">AttributeLayerConfig</a></li><li><a href="module-AttributeTable.AttributeLayersConfig.html">AttributeLayersConfig</a></li><li><a href="module-AttributeTable-AttributeLayerConfig.html">AttributeLayerConfig</a></li><li><a href="module-Attribution.AttributionConfig.html">AttributionConfig</a></li><li><a href="module-Attribution-AttributionConfig.html">AttributionConfig</a></li><li><a href="module-BaseLayer.BaseLayerConfig.html">BaseLayerConfig</a></li><li><a href="module-BaseLayer.BaseLayersConfig.html">BaseLayersConfig</a></li><li><a href="module-BaseLayer.BingBaseLayerConfig.html">BingBaseLayerConfig</a></li><li><a href="module-BaseLayer.EmptyBaseLayerConfig.html">EmptyBaseLayerConfig</a></li><li><a href="module-BaseLayer.WmsBaseLayerConfig.html">WmsBaseLayerConfig</a></li><li><a href="module-BaseLayer.WmtsBaseLayerConfig.html">WmtsBaseLayerConfig</a></li><li><a href="module-BaseLayer.XyzBaseLayerConfig.html">XyzBaseLayerConfig</a></li><li><a href="module-BaseLayerState.BaseLayerState.html">BaseLayerState</a></li><li><a href="module-BaseLayerState.BaseLayersState.html">BaseLayersState</a></li><li><a href="module-BaseLayerState.BingBaseLayerState.html">BingBaseLayerState</a></li><li><a href="module-BaseLayerState.EmptyBaseLayerState.html">EmptyBaseLayerState</a></li><li><a href="module-BaseLayerState.WmsBaseLayerState.html">WmsBaseLayerState</a></li><li><a href="module-BaseLayerState.WmtsBaseLayerState.html">WmtsBaseLayerState</a></li><li><a href="module-BaseLayerState.XyzBaseLayerState.html">XyzBaseLayerState</a></li><li><a href="module-BaseLayers-BaseLayers.html">BaseLayers</a></li><li><a href="module-BaseLayer-BaseLayerConfig.html">BaseLayerConfig</a></li><li><a href="module-BaseObject.BaseObjectConfig.html">BaseObjectConfig</a></li><li><a href="module-BaseObject.BaseObjectLayerConfig.html">BaseObjectLayerConfig</a></li><li><a href="module-BaseObject.BaseObjectLayersConfig.html">BaseObjectLayersConfig</a></li><li><a href="module-BaseObject-BaseObjectLayerConfig.html">BaseObjectLayerConfig</a></li><li><a href="module-Config.Config.html">Config</a></li><li><a href="module-Config-Config.html">Config</a></li><li><a href="module-Dataviz.DatavizElementConfig.html">DatavizElementConfig</a></li><li><a href="module-Dataviz.DatavizLayersConfig.html">DatavizLayersConfig</a></li><li><a href="module-Dataviz.DatavizOptionsConfig.html">DatavizOptionsConfig</a></li><li><a href="module-Dataviz.DatavizPlotConfig.html">DatavizPlotConfig</a></li><li><a href="module-Dataviz.DatavizTraceConfig.html">DatavizTraceConfig</a></li><li><a href="module-Digitizing-Digitizing.html">Digitizing</a></li><li><a href="module-Draw-Draw.html">Draw</a></li><li><a href="module-Edition.EditionCapabilitiesConfig.html">EditionCapabilitiesConfig</a></li><li><a href="module-Edition.EditionLayerConfig.html">EditionLayerConfig</a></li><li><a href="module-Edition.EditionLayersConfig.html">EditionLayersConfig</a></li><li><a href="module-Edition-Edition.html">Edition</a></li><li><a href="module-Errors-ConversionError.html">ConversionError</a></li><li><a href="module-Errors-HttpError.html">HttpError</a></li><li><a href="module-Errors-PropertyRequiredError.html">PropertyRequiredError</a></li><li><a href="module-Errors-ValidationError.html">ValidationError</a></li><li><a href="module-Extent.Extent.html">Extent</a></li><li><a href="module-FeatureStorage-FeatureStorage.html">FeatureStorage</a></li><li><a href="module-FeatureToolbar-FeatureToolbar.html">FeatureToolbar</a></li><li><a href="module-FormFilter.FormFilterConfig.html">FormFilterConfig</a></li><li><a href="module-FormFilter.FormFilterElementConfig.html">FormFilterElementConfig</a></li><li><a href="module-FormFilter-FormFilterElementConfig.html">FormFilterElementConfig</a></li><li><a href="module-FullScreen-FullScreen.html">FullScreen</a></li><li><a href="module-GeolocationSurvey-GeolocationSurvey.html">GeolocationSurvey</a></li><li><a href="module-Geolocation-Geolocation.html">Geolocation</a></li><li><a href="module-Layer.LayerConfig.html">LayerConfig</a></li><li><a href="module-Layer.LayersConfig.html">LayersConfig</a></li><li><a href="module-LayerState.LayerGroupState.html">LayerGroupState</a></li><li><a href="module-LayerState.LayerItemState.html">LayerItemState</a></li><li><a href="module-LayerState.LayerLayerState.html">LayerLayerState</a></li><li><a href="module-LayerState.LayerRasterState.html">LayerRasterState</a></li><li><a href="module-LayerState.LayerVectorState.html">LayerVectorState</a></li><li><a href="module-LayerState.LayersAndGroupsCollection.html">LayersAndGroupsCollection</a></li><li><a href="module-LayerTree.LayerBoundingBoxConfig.html">LayerBoundingBoxConfig</a></li><li><a href="module-LayerTree.LayerGeographicBoundingBoxConfig.html">LayerGeographicBoundingBoxConfig</a></li><li><a href="module-LayerTree.LayerStyleConfig.html">LayerStyleConfig</a></li><li><a href="module-LayerTree.LayerTreeGroupConfig.html">LayerTreeGroupConfig</a></li><li><a href="module-LayerTree.LayerTreeItemConfig.html">LayerTreeItemConfig</a></li><li><a href="module-LayerTree.LayerTreeLayerConfig.html">LayerTreeLayerConfig</a></li><li><a href="module-LayerTreeState.LayerTreeGroupState.html">LayerTreeGroupState</a></li><li><a href="module-LayerTreeState.LayerTreeItemState.html">LayerTreeItemState</a></li><li><a href="module-LayerTreeState.LayerTreeLayerState.html">LayerTreeLayerState</a></li><li><a href="module-Legend-Legend.html">Legend</a></li><li><a href="module-Locate.LocateByLayerConfig.html">LocateByLayerConfig</a></li><li><a href="module-Locate.LocateLayerConfig.html">LocateLayerConfig</a></li><li><a href="module-MGRS-MGRS.html">MGRS</a></li><li><a href="module-MapLayerState.MapGroupState.html">MapGroupState</a></li><li><a href="module-MapLayerState.MapItemState.html">MapItemState</a></li><li><a href="module-MapLayerState.MapLayerState.html">MapLayerState</a></li><li><a href="module-MapState.MapState.html">MapState</a></li><li><a href="module-Mask-Mask.html">Mask</a></li><li><a href="module-Metadata.MetadataConfig.html">MetadataConfig</a></li><li><a href="module-MousePosition-MousePosition.html">MousePosition</a></li><li><a href="module-Options.OptionsConfig.html">OptionsConfig</a></li><li><a href="module-OverviewMap-OverviewMap.html">OverviewMap</a></li><li><a href="module-PasteGeom-pasteGeom.html">pasteGeom</a></li><li><a href="module-Permalink-Permalink.html">Permalink</a></li><li><a href="module-Popup-Popup.html">Popup</a></li><li><a href="module-PrintTemplate.PrintAtlasConfig.html">PrintAtlasConfig</a></li><li><a href="module-PrintTemplate.PrintLabelConfig.html">PrintLabelConfig</a></li><li><a href="module-PrintTemplate.PrintMapConfig.html">PrintMapConfig</a></li><li><a href="module-PrintTemplate.PrintTemplateConfig.html">PrintTemplateConfig</a></li><li><a href="module-Print-Print.html">Print</a></li><li><a href="module-ProxyEvents-ProxyEvents.html">ProxyEvents</a></li><li><a href="module-ReverseGeom-reverseGeom.html">reverseGeom</a></li><li><a href="module-Scaleline-Scaleline.html">Scaleline</a></li><li><a href="module-Search-Search.html">Search</a></li><li><a href="module-SelectionInvert-SelectionInvert.html">SelectionInvert</a></li><li><a href="module-SelectionTool-SelectionTool.html">SelectionTool</a></li><li><a href="module-Snapping-Snapping.html">Snapping</a></li><li><a href="module-State.State.html">State</a></li><li><a href="module-State-GeolocationSurvey.html">GeolocationSurvey</a></li><li><a href="module-State-SelectionTool.html">SelectionTool</a></li><li><a href="module-State-State.html">State</a></li><li><a href="module-SymbologyState.BaseIconSymbology.html">BaseIconSymbology</a></li><li><a href="module-SymbologyState.BaseObjectSymbology.html">BaseObjectSymbology</a></li><li><a href="module-SymbologyState.BaseSymbolsSymbology.html">BaseSymbolsSymbology</a></li><li><a href="module-SymbologyState.LayerGroupSymbology.html">LayerGroupSymbology</a></li><li><a href="module-SymbologyState.LayerIconSymbology.html">LayerIconSymbology</a></li><li><a href="module-SymbologyState.LayerSymbolsSymbology.html">LayerSymbolsSymbology</a></li><li><a href="module-SymbologyState.SymbolIconSymbology.html">SymbolIconSymbology</a></li><li><a href="module-SymbologyState.SymbolRuleSymbology.html">SymbolRuleSymbology</a></li><li><a href="module-Theme.LayerThemeConfig.html">LayerThemeConfig</a></li><li><a href="module-Theme.ThemeConfig.html">ThemeConfig</a></li><li><a href="module-Theme.ThemesConfig.html">ThemesConfig</a></li><li><a href="module-TimeManager.TimeManagerLayerConfig.html">TimeManagerLayerConfig</a></li><li><a href="module-TimeManager.TimeManagerLayersConfig.html">TimeManagerLayersConfig</a></li><li><a href="module-TimeManager-TimeManagerLayerConfig.html">TimeManagerLayerConfig</a></li><li><a href="module-Tooltip.TooltipLayerConfig.html">TooltipLayerConfig</a></li><li><a href="module-Tooltip.TooltipLayersConfig.html">TooltipLayersConfig</a></li><li><a href="module-Treeview-Treeview.html">Treeview</a></li><li><a href="module-Utils-Utils.html">Utils</a></li><li><a href="module-WFS-WFS.html">WFS</a></li><li><a href="module-WMS-WMS.html">WMS</a></li><li><a href="module-maps-map.html">map</a></li></ul><h3>Events</h3><ul><li><a href="module-Action.html#~event:actionResultReceived">actionResultReceived</a></li><li><a href="global.html#event:beforetreecreated">beforetreecreated</a></li><li><a href="global.html#event:layersadded">layersadded</a></li><li><a href="global.html#event:mapcreated">mapcreated</a></li><li><a href="global.html#event:treecreated">treecreated</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addListener">addListener</a></li><li><a href="global.html#dispatch">dispatch</a></li><li><a href="global.html#removeListener">removeListener</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Wed Feb 14 2024 14:50:29 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
